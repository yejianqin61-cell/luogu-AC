# C++ vector 与范围循环详解

## 目录

- 一、二维向量 vector<vector<int>>
- 二、push_back 添加元素
- 三、遍历向量的三种方法
- 四、引用 & 详解
- 五、完整代码示例

------

## 一、二维向量 vector<vector<int>>

### 基本概念

cpp

```
vector<vector<int>> solutions;  // 定义一个二维动态数组
```

### 数据结构理解

text

```
solutions = [
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 2],  // 第0个方案
    [1, 1, 1, 1, 1, 1, 1, 1, 2, 1],  // 第1个方案
    [1, 1, 1, 1, 1, 1, 1, 2, 1, 1],  // 第2个方案
    ...
]
```

### 层次结构

- **外层vector**：存储多个方案
- **内层vector**：存储每个方案的10个配料值
- **访问方式**：`solutions[i][j]` 表示第i个方案的第j个配料

------

## 二、push_back 添加元素

### 基本用法

cpp

```
solutions.push_back({a, b, c, d, e, f, g, h, i, j});
```

### 执行过程

1. 创建一个包含10个整数的临时数组 `{a, b, c, ...}`
2. 将这个数组作为一个完整的方案
3. 添加到solutions容器的末尾

### 类比理解

就像往笔记本里一页一页添加内容：

- 第一页：方案1
- 第二页：方案2
- 第三页：方案3

------

## 三、遍历向量的三种方法

### 方法1：最基础的索引遍历（推荐初学者使用）

cpp

```
int total = solutions.size();  // 获取方案总数

for (int i = 0; i < total; i++) {
    // solutions[i] 是第i个方案
    for (int j = 0; j < 10; j++) {
        cout << solutions[i][j];  // 输出第i个方案的第j个配料
        if (j < 9) cout << " ";    // 空格分隔
    }
    cout << endl;  // 每个方案换行
}
```

### 方法2：带引用的索引遍历

cpp

```
for (int index = 0; index < solutions.size(); index++) {
    vector<int>& sol = solutions[index];  // sol是第index个方案的引用
    // 处理sol
}
```

### 方法3：范围for循环（C++11引入）

cpp

```
for (auto& sol : solutions) {
    // sol依次代表每个方案
    for (int k = 0; k < 10; k++) {
        cout << sol[k];
        if (k < 9) cout << " ";
    }
    cout << endl;
}
```

### 三种方法执行过程对比（假设有3个方案）

**方法1执行过程：**

text

```
i=0: solutions[0][0] solutions[0][1] ... solutions[0][9]
i=1: solutions[1][0] solutions[1][1] ... solutions[1][9]
i=2: solutions[2][0] solutions[2][1] ... solutions[2][9]
```

**方法2执行过程：**

text

```
index=0: sol指向solutions[0] → 输出方案0
index=1: sol指向solutions[1] → 输出方案1
index=2: sol指向solutions[2] → 输出方案2
```

**方法3执行过程：**

text

```
第一次循环: sol = solutions[0] → 输出方案0
第二次循环: sol = solutions[1] → 输出方案1
第三次循环: sol = solutions[2] → 输出方案2
```

------

## 四、引用 & 详解

### 引用的基本概念

引用就是给变量起一个"别名"，操作引用就是操作原变量。

### 引用 vs 指针

| 特性 | 引用 (&)        | 指针 (*)          |
| ---- | --------------- | ----------------- |
| 本质 | 变量的别名      | 存储地址的变量    |
| 定义 | `int& ref = a;` | `int* ptr = &a;`  |
| 使用 | 直接使用 `ref`  | 需要解引用 `*ptr` |
| 内存 | 不占额外内存    | 占用内存存储地址  |
| 空值 | 不能为空        | 可以为nullptr     |

### 代码对比

cpp

```
// 引用方式
vector<int>& sol = solutions[index];
cout << sol[0];  // 直接使用

// 指针方式
vector<int>* ptr = &solutions[index];
cout << (*ptr)[0];  // 需要先解引用
```

### 为什么使用引用？

cpp

```
// 不使用引用（复制数据，浪费内存）
vector<int> sol = solutions[index];  // 复制一份新数据

// 使用引用（直接操作原数据，高效）
vector<int>& sol = solutions[index];  // 只是起个别名
```

### 类比理解

- **变量**：一个人
- **引用**：这个人的外号/昵称
- **指针**：这个人的家庭住址

------

## 五、完整代码示例

### 烤鸡问题完整解法

cpp

```
#include <bits/stdc++.h>
using namespace std;

int main() {
    cin.tie(0);
    int n;
    cin >> n;
    
    // 判断n是否在有效范围内（10种配料，每种1-3克）
    if (n < 10 || n > 30) {
        cout << "0" << endl;
        return 0;
    }
    
    vector<vector<int>> solutions;  // 存储所有方案
    
    // 10层循环枚举所有可能
    for (int a = 1; a <= 3; a++)
    for (int b = 1; b <= 3; b++)
    for (int c = 1; c <= 3; c++)
    for (int d = 1; d <= 3; d++)
    for (int e = 1; e <= 3; e++)
    for (int f = 1; f <= 3; f++)
    for (int g = 1; g <= 3; g++)
    for (int h = 1; h <= 3; h++)
    for (int i = 1; i <= 3; i++)
    for (int j = 1; j <= 3; j++) {
        if (a + b + c + d + e + f + g + h + i + j == n) {
            solutions.push_back({a, b, c, d, e, f, g, h, i, j});
        }
    }
    
    // 输出方案总数
    cout << solutions.size() << endl;
    
    // 遍历输出所有方案（使用最基础的方法）
    int total = solutions.size();
    for (int i = 0; i < total; i++) {
        for (int j = 0; j < 10; j++) {
            cout << solutions[i][j];
            if (j < 9) cout << " ";
        }
        cout << endl;
    }
    
    return 0;
}
```

### 关键点总结

1. **vector<vector<int>>** 是二维动态数组
2. **push_back** 用于添加新元素
3. 遍历方法有三种：索引、引用+索引、范围for
4. **引用(&)** 是别名，不是指针，操作更简单
5. 烤鸡问题n的有效范围是10-30